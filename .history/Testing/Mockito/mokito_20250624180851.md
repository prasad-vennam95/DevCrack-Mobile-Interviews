### Q: What is Mockito and why is it used?

**A:**  
Mockito is a popular open-source Java framework used for unit testing by creating mock objects. It allows developers to simulate the behavior of complex, real objects and verify interactions, making it easier to write and maintain tests.

---

### Q: How do you create a mock object in Mockito?

**A:**  
You can create a mock object using the `@Mock` annotation or the `Mockito.mock()` method.  
Example:  
```java
List<String> mockedList = Mockito.mock(List.class);
```

---

### Q: What is the purpose of the `when` and `thenReturn` methods in Mockito?

**A:**  
`when` and `thenReturn` are used to define the behavior of a mock object when a particular method is called.  
Example:  
```java
when(mockedList.get(0)).thenReturn("Hello World");
```

---

### Q: How do you verify that a method was called on a mock object in Mockito?

**A:**  
You can use the `verify()` method to check if a method was called with specific arguments.  
Example:  
```java
verify(mockedList).add("test");
```

---

### Q: How do you simulate exceptions using Mockito?

**A:**  
You can use `thenThrow()` to simulate exceptions when a mock method is called.  
Example:  
```java
when(mockedList.get(1)).thenThrow(new RuntimeException());
```

---

### Q: What is the difference between `@Mock` and `@InjectMocks` in Mockito?

**A:**  
- `@Mock` creates a mock instance of a class.
- `@InjectMocks` creates an instance of the class and automatically injects the mocks marked with `@Mock` (or other mock objects) into it.

---

### Q: Can Mockito be used for testing Android or iOS apps?

**A:**  
Mockito is primarily for Java and is commonly used in Android unit testing. It is not used for iOS (Swift/Objective-C) testing, but similar mocking frameworks exist for those platforms (e.g., Cuckoo for Swift).

---

### Q: What are some alternatives to Mockito?

**A:**  
- EasyMock  
- JMock  
- PowerMock (for advanced use-cases)  
- MockK (for Kotlin)

---

### Q: Why should you use mocking in unit tests?

**A:**  
Mocking helps isolate the unit of code under test by simulating dependencies, making tests more reliable, faster, and focused. It avoids the complexity and instability of using real objects, especially external systems or resources.

---